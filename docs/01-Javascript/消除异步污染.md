---
title: 消除异步带来的污染
---

有时候为了保证函数的纯粹,需要删除异步的污染
1. 没消除污染函数执行顺序: 发送真实请求 -> 依赖函数(被污染,async)等待请求 => 执行相关逻辑
2. 消除异步污染执行顺序: 发送真实请求 -> 直接抛出错误(throw之后网络进程并不会终止) -> 等待刚刚的请求拿到数据 -> 再次发送请求,拿到缓存 -> 执行相关逻辑
**注意: 为了保持函数的纯粹性, 这类问题最好是封装一个运行时环境,当前情况,这个运行时情况需要改变原有的fetch函数**  
```jsx title="完整代码"
const Fetch = () => {
    const a = fetch('');
    return a;
}

//消除异步之后的test
const test =  () =>{
    const temp =  Fetch();
    console.log(temp);
}
//更改执行环境
const run = (fun: Function) => {
    const oldFetch = window.fetch;
    let cache ={
    state: 3,
    value :null ,
    };
    //更改fetch
    window.fetch = function (...args):any {
        if (cache.state === 1) {
            //有缓存
            return cache.value;
        }
        else if (cache.state === 2) {
            //请求失败了
            throw cache.value;
        }
        //没有发送过请求,发送一次真实的请求
        else {
            //同步代码
            const temp = oldFetch(...args).then(res =>{
                cache.state = 1
                cache.value  = res ; 
            }).catch(err=>{
                cache.value= err;
                cache.state =2
            })
            throw temp;
        }
    }
    //调用fun
    try{
        fun();  //第一次执行
    }
    catch(err){
        //判断是否是promise
        if(err instanceof Promise){
            //第二次执行
        err.then(res=>fun())
        .catch(err=> fun())
        //将fetch改回原来的版本
        .finally(()=>window.fetch=oldFetch);
        }
    }
    //还原fetch
}
run(test);


//很重要
// const test = async () =>{
//     temp1 =  Fetch();
//      throw 123
// }为什么加了这个async之后我的error就不能被catch

```